# filename: codebase/verify_output_csv.py
import pandas as pd
import numpy as np
import os

def verify_output_csv():
    """
    Verifies the 'result.csv' file generated by the CAMB power spectrum calculation.

    Checks for:
    - File existence.
    - Correct column names ('k', 'rel_diff').
    - Correct number of data rows (200).
    - Plausible range for 'k' values (h/Mpc).
    - Presence of NaN or Inf in 'rel_diff'.
    - Calculates and prints the maximum absolute relative difference and the k at which it occurs.
    """
    data_dir = "data"
    csv_filename = os.path.join(data_dir, "result.csv")
    
    print("Starting verification of " + csv_filename + "...")

    # Check 1: File existence
    if not os.path.exists(csv_filename):
        print("Error: File " + csv_filename + " not found. Please run the calculation script first.")
        return

    print("File " + csv_filename + " found.")

    try:
        # Load the CSV file
        df = pd.read_csv(csv_filename)
        print("Successfully loaded " + csv_filename + ".")

        # Check 2: Column names
        expected_columns = ['k', 'rel_diff']
        if list(df.columns) == expected_columns:
            print("Column names check: Passed. Found columns: " + str(list(df.columns)))
        else:
            print("Error: Column names check: Failed. Expected " + str(expected_columns) + " but got " + str(list(df.columns)))
            return

        # Check 3: Number of rows
        expected_rows = 200
        if len(df) == expected_rows:
            print("Number of rows check: Passed. Found " + str(len(df)) + " rows.")
        else:
            print("Error: Number of rows check: Failed. Expected " + str(expected_rows) + " but got " + str(len(df)) + " rows.")
            return

        # Check 4: k values range and units
        # k is expected to be in h/Mpc, ranging from 1e-4 to 2.0
        k_min_expected = 1e-4
        k_max_expected = 2.0
        
        k_values = df['k']  # k in h/Mpc
        
        if k_values.min() >= k_min_expected * 0.99 and k_values.max() <= k_max_expected * 1.01:
            print("k values range check: Passed.")
            print("Min k value: " + str(k_values.min()) + " h/Mpc (Expected approx. " + str(k_min_expected) + " h/Mpc)")
            print("Max k value: " + str(k_values.max()) + " h/Mpc (Expected approx. " + str(k_max_expected) + " h/Mpc)")
        else:
            print("Error: k values range check: Failed.")
            print("Min k value: " + str(k_values.min()) + " h/Mpc (Expected approx. " + str(k_min_expected) + " h/Mpc)")
            print("Max k value: " + str(k_values.max()) + " h/Mpc (Expected approx. " + str(k_max_expected) + " h/Mpc)")
            # Do not return, as other checks might still be useful

        if not k_values.is_monotonic_increasing:
            print("Warning: k values are not strictly increasing.")
        else:
            print("k values monotonicity check: Passed (k values are sorted).")

        
        # Check 5: rel_diff values integrity
        rel_diff_values = df['rel_diff']  # Dimensionless relative difference
        
        if rel_diff_values.isnull().any():
            print("Error: 'rel_diff' column contains NaN values.")
            # Do not return, proceed to check for Inf
        else:
            print("'rel_diff' NaN check: Passed. No NaN values found.")

        if np.isinf(rel_diff_values).any():
            print("Error: 'rel_diff' column contains Inf values.")
            # Do not return
        else:
            print("'rel_diff' Inf check: Passed. No Inf values found.")
            
        print("Min rel_diff value: " + str(rel_diff_values.min()))
        print("Max rel_diff value: " + str(rel_diff_values.max()))

        
        # Summary: Maximum absolute relative difference
        # Ensure we only consider finite values for this calculation
        finite_rel_diff = rel_diff_values[np.isfinite(rel_diff_values)]
        if not finite_rel_diff.empty:
            max_abs_rel_diff_idx = finite_rel_diff.abs().idxmax()
            abs_rel_diff = df['rel_diff'].abs()
            valid_abs_rel_diff = abs_rel_diff[np.isfinite(df['rel_diff'])]  # Filter out non-finite before finding max

            if not valid_abs_rel_diff.empty:
                max_abs_val = valid_abs_rel_diff.max()
                idx_of_max_abs = valid_abs_rel_diff.idxmax()
                
                k_at_max_abs_rel_diff = df['k'].iloc[idx_of_max_abs]  # k (h/Mpc)
                actual_rel_diff_at_max_abs = df['rel_diff'].iloc[idx_of_max_abs]  # Actual value (could be negative)

                print("\nSummary of Relative Difference:")
                print("Maximum absolute relative difference: " + str(max_abs_val))
                print("This occurs at k = " + str(k_at_max_abs_rel_diff) + " h/Mpc.")
                print("The actual relative difference at this k is: " + str(actual_rel_diff_at_max_abs))
            else:
                print("Could not determine maximum absolute relative difference as all 'rel_diff' values are non-finite.")

        else:
            print("Warning: All 'rel_diff' values are non-finite (NaN or Inf). Cannot determine maximum absolute relative difference.")

        # Final Confirmation
        print("\nVerification complete.")
        if (list(df.columns) == expected_columns and
            len(df) == expected_rows and
            k_values.min() >= k_min_expected * 0.99 and k_values.max() <= k_max_expected * 1.01 and
            not rel_diff_values.isnull().any() and
            not np.isinf(rel_diff_values).any()):
            print("The file " + csv_filename + " appears to be correct and ready for further analysis or sharing.")
        else:
            print("The file " + csv_filename + " has some issues as noted above. Please review.")

    except pd.errors.EmptyDataError:
        print("Error: The file " + csv_filename + " is empty.")
    except Exception as e:
        print("An error occurred during verification of " + csv_filename + ":")
        import traceback
        print(traceback.format_exc())

if __name__ == '__main__':
    verify_output_csv()